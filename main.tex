\documentclass[a4paper,10pt]{report}
\usepackage{fullpage}
\usepackage{setspace}
\usepackage[margin=1.0in]{geometry}
\usepackage[T1]{fontenc}
\usepackage{mathtools}
\usepackage{url}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{xcolor}

\lstset{language=C++,
  breaklines=true,
  breakatwhitespace=true,
                basicstyle=\small\tt,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#}
}



\begin{document}
\title{3D Procedurally Generated Nature Scene}
\author{Author: Pip Turner - pit@aber.ac.uk  \\
Supervisor: Reyer Zwiggelaar \\
G400 Computer Science \\
CS39440}
\date{\parbox{\linewidth}{\centering%
  \today\endgraf\bigskip
  \textit{Version 1.0}
  }}
\maketitle

\centering
    {\LARGE\bf Acknowledgements}


I am grateful to...

I'd like to thank..

\clearpage
 \raggedright
 
 
%%%
%%% You must sign the declaration of originality. 
%%%
%%% You are submitting this electronically. Therefore, to sign, you 
%%% type your name and date to replace the .... characters. 
%%%
\begin{center}
    {\LARGE\bf Declaration of originality}
\end{center}

I confirm that:

\begin{itemize}
\item{This submission is my own work, except where 
clearly indicated.}

\item{I understand that there are severe penalties for Unacceptable Academic Practice, which can lead to loss of marks or even the withholding of a degree.}
 
\item{I have read the regulations on Unacceptable Academic Practice from the University's Academic Quality and Records Office (AQRO) and the relevant sections of the current Student Handbook of the Department of Computer Science.}
 
\item{In submitting this work I understand and agree to abide by the University's regulations governing these issues.}
\end{itemize}

\vspace{2em}
Name: Pip Turner  \\

\vspace{1em}
Date: 30/04/18 \\

%%% 
%%% We would like to make a selection of final reports available to students that take 
%%% this module in future years. To enable us to do this, we require your consent. You 
%%% are not required that you do this, but if you do give your consent, then we will have 
%%% the option to select yours as one of a number of reports as examples for other 
%%% students. If you would like to give your consent, then please include the following 
%%% text and type your name and date to replace the .... characters. 
%%% 
%%% If you do not wish to give your consent, please remove this from your report. 
%%%
\vspace{1em}
\begin{center}
    {\LARGE\bf Consent to share this work}
\end{center}

By including my name below, I hereby agree to this dissertation being made available to other students and academic staff of the Aberystwyth Computer Science Department.  

\vspace{2em}
Name: Pip Turner  \\

\vspace{1em}
Date: 30/04/18 \\

\setlength{\headheight}{20.2pt}
\pagestyle{fancy}
\setlength{\headsep}{0.2in}
\fancyhf{}

\fancyhead[L]{\leftmark}
\fancyhead[R]{\rightmark}

\fancyfoot[C]{\thepage}

\listoffigures
\listoftables

\tableofcontents
\clearpage



\section{Abstract}
3D Procedural Generation is a way to produce high variety 3D models quickly without manually creating the content. This Project is going to focus on the implementation and subsequent levels of variation of Procedural Generation Algorithms in order to create a cohesive scene. This project will focus on creating nature based content, e.g. Terrain, Trees and Foliage in order to combine them together and create a dense scene which also renders smoothly. 
\clearpage
\chapter{Introduction}
\section{Project Description}

Procedural Content Generation is a broad term referring to the creation of content automatically through algorithmic means~\cite{yannakakis2011experience}. The most popular examples of Procedural Generation are usually the use of it in creating procedurally Generated Worlds, such as No Man's Sky~\cite{nomanssky} - a game which provides the player with a procedurally generated universe to explore. Projects which aim to generate entire planets, or even universes are what initially provided inspiration for this project to be focused around procedural generation - the vast scope, potential and variety of scenes in particular. \medskip


\begin{figure}[h!]
    \centering
  \includegraphics[width=0.9\textwidth]{NoMansSky}
 \caption{No Man's Sky. Source: https://www.nomanssky.com/press/}
 \label{fig:no_mans_sky}
\end{figure}


This project, therefore is a 3D Procedurally Generated Nature Scene - a small, dense scene utilising procedural content generation techniques to create a  scene which is visibly different each time it is generated. \medskip

However, upon beginning this project, personal knowledge of all areas within this project was limited - this project is as much a personal opportunity to learn low level 3D Graphics and Procedural Generation techniques as it is simply an exercise in implementing them. 

\section{Project Aims}
The aims of the project are as follows:\medskip

\textbf{\textit{Create a 3D Procedurally Generated Nature Scene}} \medskip

The heart of this project is creating a 3D nature scene which is different each time it is generated, using 3D Procedural Content Generation. Rather than creating large, vast swathes of land, this project is instead aiming for a smaller, dense scene in order to generate more interesting landscapes. The smaller the scene, the less content is needed to be generated in order to ensure high levels of variation.\medskip

The main work involved in this aim will be the implementation and subsequent optimisation and use of procedural algorithms. The basic two ingredients needed are Terrain and Trees - this would at the very least show a good understanding and implementation of two to three procedural algorithms. Once these are well implemented, foliage and other details can be added in order to increase the variety of the scene, further progressing the detail and complexity of the scene.  \medskip


\textbf{\textit{Become competent with C++, OpenGL and the core fundamentals of low level graphics}} \medskip

The other main aim of this project is in regards to the skills and technologies learnt whilst working on it. This project was begun with a basic understanding of C++, basic ideas about procedural generation algorithms and no understanding of OpenGL (albeit some basic knowledge of graphics and graphics libraries). Upon completion of this project, there should be a huge jump in knowledge and skills learnt, with a greater appreciation and understanding of C++, procedural generation algorithms and OpenGL.\medskip

\chapter{Research}

In researching into this project, suitable algorithms were needed to be found. Two categories were decided upon - Terrain and Objects on the Terrain. \medskip

\section{Existing Solutions}

\subsection{Terrain}

A major part of this project was selecting and subsequently implementing a terrain algorithm which produced suitably varied and realistic looking terrain. One of the most popular noise generation techniques for Procedural terrain is Perlin Noise~\cite{perlin2002improving} - an algorithm which has been widely used for 3D Graphics, and something which has been instrumental in improving 3D graphics. Whilst it is a popular algorithm, it can be quite computationally expensive and difficult to implement in comparison to other algorithms.\medskip

The supervisor to the project, Reyer Zwiggelaar, suggested looking into Fractal Images, initially suggesting some realistic natural growth based algorithms~\cite{Bilsborough3424}. One of the most widely used Fractal Terrain algorithms is Diamond Square~\cite{olsen2004realtime} - a variation on midpoint displacement. Midpoint Displacement's main issue was that when generating a heightmap it often left "creases" in its landscape, an issue Diamond Square aims to fix by using two stages of midpoint displacement - named Square and Diamond.  \medskip

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.5\textwidth]{DiamondSquareGreyScale}
 \caption{Diamond Square Terrain with a Greyscale colour applied to it}
 \label{fig:DiamondSquareGrey}
\end{figure}

\subsection{Objects on Terrain}

As well as procedural terrain, in order to ensure a high level of variety, objects upon the terrain are going to also need to be generated. This project will focus mainly on foliage, i.e. Trees, plants and grass. In researching procedurally generated trees two methods were identified as possible implementations - Lindenmayer Systems~\cite{lindenmayer2017} or a Space Colonisation Algorithm~\cite{runions2007modeling}. 

Lindenmayer System is a fractal generation algorithm which builds a fractal by iterating over a string, following a rule set~\cite{prusinkiewicz2012algorithmic}~\cite{crownover1995introduction}. The string can then be interpreted into something drawable. This allows for infinite number of unique fractal patterns to be generated, but most importantly, it can be used to generate trees, bushes and grass like fractals.  

Space Colonisation~\cite{runions2007modeling} works by defining an area in space, filling it with "seeds" (points in space) and "growing" branches towards those points. By doing this, it becomes an incredibly powerful tree generator - generating a huge variety of trees depending on the defined area and the amount of seeds.

\subsection{Optimisation}
This project will require displaying a lot of objects and vertices at once, meaning that optimisation techniques will need to be implemented, as the more vertices on the screen, the lower the frame rate. In order to display the scene professionally, we need to aim for a high frame rate (between 30 and 60).  \medskip

There are a number of big optimisation techniques associated with 3D Graphics. The most applicable optimisation to both Terrain and Trees is Level Of Detail. The further the way an object is from the user, the less detailed the object needs to be. For example, if the player is looking at a far off Mountain, they won't be able to see all of the nooks and crannies on it, only the general shape. This means that we can severely decrease the number of vertices on objects which are far away, whilst keeping high detail on objects which are closer. \medskip

Level of detail is even more relevant when displaying objects like trees, bushes and grass. We can go even further with these using Billboards and Impostors~\cite{jia2013fast}. The basic premise of them is if the tree is far enough from the player for the player to not realise, we can generate an image of the tree and display the image instead. For Example, if we have a tree with five hundred vertices, we can simply display it using six, by mapping the image of the tree onto a quadrilateral polygon made up of two triangles. These images can differ depending on how far away the object is from the player. If the object is very far, we can simply display one image of it, oriented towards the player - this is known as \textit{Billboarding}. However, if the object is a bit closer to the player, we can display an image of the tree at a certain rotation, giving the illusion of perspective to the player. The implementation of Billboards and Impostors can also vary from object to object. Grass, as it is so small can potentially simply be displayed as a Billboard for all of its lifetime. billboard and impostor optimisations can provide huge boost to the frame rate , drastically cutting down the number of polygons in the scene whilst maintaining the illusion of density. \medskip

Objects on the Terrain can also be optimised using instancing and by implementing the Flyweight Design Pattern (\emph{see section 1.5.4}). Instance Rendering allows us to draw the same tree multiple times in different places, whilst only ever storing the data of it once. This saves hugely on memory space.  


\subsection{Design Patterns}

There were no Architectural Design Patterns which seemed relevant for this project. Model View Controller~\cite{vlissides1995design} was considered, but when implementation was theorised, it was found that the pattern simply didn't fit this project - it would be overkill to implement a pattern which lent so heavily on a database on a project which doesn't require any database functionality. \medskip

However, two programming patterns have been identified which are relevant to the project: Flyweight and Command~\cite{nystrom2014game}.\medskip

\emph{\textbf{Flyweight}}\medskip

Flyweight allows you to share common information between objects. This is hugely useful for Trees - they may have the same mesh, colour details or texture. Separating out this data, and then having the instances of the trees carry a pointer to the data can allow for optimised data sharing. \medskip

\emph{\textbf{Command}}\medskip

Command can be used for different inputs the player makes. Instead of hard coding each key press, we can implement command, which abstracts the key press from the command, allowing for easy remapping of keys. This can come in useful for handling movement within the program. 

\section{Suitability of Algorithms}

\subsection{Terrain}

For Terrain, the Diamond Square algorithm will be used. As this project will be completed with limited initial knowledge, choosing an algorithm which is relatively simple to implement, and which produces similar results to Perlin noise is preferable. As Diamond Square is less complex, it also takes less time to generate its height map. However, in comparison to Perlin Noise, it is less flexible - Perlin Noise can be used to generate infinite surroundings on the fly, needing no knowledge of points next to it, whereas Diamond Square Terrain needs to be generated as a whole before it is rendered, meaning that chunks would have to be stitched together to create infinite terrain. However, as the aim of this project is not to provide infinite terrain, but rather a variation on a small part of Terrain, this is not too much of an issue for me. 

\subsubsection{Objects}

When adding objects to the terrain, a high level of variety is preferred. As the time on this project is limited, the Lindenmayer System algorithm will be used, instead of Space Colonisation. In using L-Systems, a high range of different fractals can be used, providing an interesting scene to look at. Lindenmayer Systems are not only fast and have a low memory footprint, they allow for huge variation in not just trees but in creating other objects such as plants, grass and bushes. 

\section{Proposed Implementation}
\subsection{Overview}

In creating this project, it is not only the software implementation which is important to consider, but also the development life-cycle as a whole. A well planned life-cycle can make or break a project. 

\subsection{Software Development}
\subsubsection{Life-cycle}

An Agile Methodology seemed well suited to the project, as the technologies were so new to me, and the project so dynamic in scope. Following a Waterfall style system wouldn't have worked as well, as a rigid plan would not have worked as effectively, due to lesser knowledge of the subject. Agile Methodologies tend to be less rigidly structured, allowing for more flexibility to learn and experiment within the project. \medskip

With this in mind, One Man Scrum Methodology was selected to be used. In a One Man Scrum tutorial, written by Alex Andrews,~\cite{andrews_2017} Andrews discusses the core principles of Scrum - Shipping features regularly, productivity and self reflection \& meaningful iteration. Scrum works by splitting development up into short sections known as "Sprints". Features of a program which need implementing are known as Stories, and each Sprint is focused around completing a specific set of stories, decided upon before the sprint began. \medskip

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.9\textwidth]{RayWenderlich}
 \caption [A proposed two week Sprint plan by Alex Andrews]{A proposed two week Sprint plan by Alex Andrews, sourced from https://www.raywenderlich.com/162654/scrum-one-bring-scrum-one-person-operation . Used with permission.}
 \label{fig:two_week_sprint_plan}
\end{figure}

As seen in Figure~\ref{fig:two_week_sprint_plan}, Andrews proposes a two week Sprint, each day featuring a Daily Scrum, followed by completion of sprint tasks. Each week ends with Story Time, with the final week ending with a Retrospective, Sprint Plan and a time for exploration. The general layout of the two weeks had been organised and put together well, it needed adaptation for this project, due to the small time frame when compared to Andrews. \medskip

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.9\textwidth]{Sprint_Plan}
 \caption{An adapted version of Alex Andrew's One Man Two-Week Sprint}
 \label{fig:one_week_sprint_plan}
\end{figure}

In Figure~\ref{fig:one_week_sprint_plan}, Andrew's Sprint was adapted into a one week solution, which spanned the entire week rather than five days. \textit{Sprint Release} was removed as the project wouldn't be releasing to the public or testers, so instead commits and features could be built up throughout the sprint. Story planning and Sprint planning were moved to the beginning of the week, to ensure a more focused week throughout. On top of this, the retrospective and exploration were moved to Sunday. \medskip

To support this, a Sprint Log was kept alongside the projects development, which was essentially a record of the daily scrum. Each day a record was kept of the intentions for the day, making sure to relate them to the stories planned and recorded on the Monday. This worked well, as Mondays also tended to be the day a meeting was held with the project's supervisor and Monday tended assigned for Write-Up. Having Monday as a planning and Write Up day gave me a good sense of motivation and a good chance to rest from programming. \medskip

\begin{figure}[h!]
    \centering
  \includegraphics[width=1\textwidth]{GanttChart.png}
 \caption{A Gantt Chart for the entire project, made with Gantt Project~\cite{gantt}}
 \label{fig:gantt_chart}
\end{figure}


Whilst an Agile Methodology is being used, it does not mean that project planning as a whole can be dismissed. On top of planning at the start of the Sprints, a Gantt Chart (see fig~\ref{fig:gantt_chart} was also used to ensure that the project was on track with both Write Up, Sprints and Project deadlines. This, coupled with the Project Outline Spec, provided a lot of insight into how to shape the project was shaped, and ensured that it would be finished on time. \medskip


\section{Relevant Technology}

\subsection{C++}

This project will be coded primarily in C++, as an aim of the project is to become more familiar and more comfortable with C++. As well as this, C++ has its own benefits - it tends to be very fast, is very often used for graphics coding due to the powerful libraries available, such as DirectX~\cite{directx_website}, OpenGL~\cite{OpenGL_website} and Vulkan. When writing in C++, it was decided to follow Google's Style Guide's~\cite{google_c_style_guide} naming conventions, in order to ensure a coherent and consistent code base.

\subsection{OpenGL}
In choosing C++, there were multiple Graphics APIs to choose from. DirectX's Direct3D was disregarded due to its limited application in terms of cross platform - it only being compatible with Windows based hardware. Vulkan, intended to be a "Next Generation OpenGL" was also eventually disregarded as an option. Despite being newer, and potentially more powerful than OpenGL, it is also more verbose and lower level and therefore harder to pick up. As the project is being made with relatively little experience with 3D Graphics APIs, previously only having experience with  high level JavaScript libraries beforehand, it was more advisable for to use OpenGL - a cross platform graphics API. Using OpenGL gives me a better way to learn the fundamentals of low level graphics, as well as the option to move onto Vulkan in the future.

\subsection{GLSL}

GLSL, or \textit{OpenGL Shading Language} is the language used by OpenGL for its shaders. Whilst shaders wont be focused on too much during the project, they are still needed by necessity, and so some GLSL will be used.

\subsection{CLion}
CLion~\cite{clion_jetbrains} was selected as the IDE of choice, as it offers powerful tools for a programmer, as well as a very slick user interface. Having had previous positive experiences with Jetbrains products, using CLion for this project seemed like an obvious choice.

\subsection{LaTeX}
In order to write this report, LaTeX~\cite{latex_website} was used, due to its professional rendering of documents. Overleaf.com~\cite{overleaf_website}, a cloud based LaTeX editor was used to edit the report in, which ensured that the report's data couldn't get lost, as it also had Github integration.

\subsection{Draw.io}
Any charts used in this document were generated using draw.io~\cite{draw_io}, an easy to use chart maker, which provided the option to save to cloud based providers, again allowing for an easy way to keep the chart data safe. 

\subsection{Version Control - Git \& Github}
This project was made using Git as version control, being saved to a private repository on Github~\cite{github}. This allowed easy rollbacks where needed, as well as ensuring that the project's data would not be lost, as it is saved on the cloud. In addition to this, Overleaf was used for version control and cloud saving for the report - it also uses a Git backend for this.

%%%%%%%%%%%%%%%% NEW CHAPTER %%%%%%%%%%%%%%%%

\chapter{Design and Implementation}

\section{Overall Architecture}

The project will perform the following processes in order when run: \bigskip

\textbf{Open a Window} \par
Firstly, the project will open a window, using GLFW~\cite{berglund2006glfw}, in order to show that it is running. \medskip

\textbf{Generate Diamond Square Heightmap} \par
The project will then generate a Diamond Square Heightmap, as the heights generated will inform a lot of the rest of the project. \medskip

\textbf{Generate Terrain Vertices} \par
The project will then convert the Heightmap into triangle based vertices, passing it to OpenGL's vertex buffer. \medskip

\textbf{Generate Terrain Colours} \par
The project will then generate the terrain colours, based off of the terrain's height. \medskip

\textbf{Generate L-Systems} \par
The project will then generate L-System fractals \medskip

\textbf{Generate L-System Positions} \par 
The project will then generate the positions of the fractals \medskip

\textbf{Draw Loop} \par
The project then enters the draw loop, not leaving until "Esc" is pressed. \medskip

\textbf{Check for Key Input} \par 
The project then checks for any input from the user, responding accordingly. \medskip

\textbf{Compute Camera MVC} \par 
The project then computes the camera's view matrix based on mouse and keyboard input. \medskip

\textbf{Draw Vertices} \par 
The project then draws the terrain, followed by trees. \medskip

\section{Software Structure}
As this project is so reliant on C++ and OpenGL, these two technologies dictate the Software's structure. C++ is primarily an Object Oriented Language, with OpenGL being a state machine and Graphics API, a structure already built into it. \\

\begin{figure}[h!]
    \centering
\includegraphics[width=0.8\textwidth]{Architecture.png} 
\caption{Diagram illustrating the architecture of the project}
\label{architecture}
\end{figure} 

In order to keep the project organised, the code was split up into two distinct parts - specific OpenGL related code, and procedural generation. As seen in fig~\ref{architecture}, OpenGL draw loop (\textit{main.cpp in the source code) controls the project} controls the OpenGL related code, whilst World Maker controls the Procedural Generation aspects of it. Separating out these two parts helped motivate a code base which was both modular in design (allowing for easily changeable code), and created an architecture which allowed for easy feature additions. \\

Diamond Square and L-Systems were split off into their own object classes, in order to allow for easy creation and generation of them, as well as to enable a more modular code design. A modular design philosophy has driven the majority of code in this project. In designing each class, functionality was separated into different, independent methods, allowing for a good deal of re-usability and flex-ability in bug fixing. C++'s vectors played a big part in ensuring the flexibility of code. Instead of relying on fixed length arrays, which create quite static code, using vectors (which can be accessed in a similar way to arrays if needed) allowed for a more dynamic and easily added to program. \\

\begin{figure}[h!]
\centering
  \fbox{\includegraphics[width=1\textwidth]{LSystemGeneration.png}}
 \caption{The method which defines and generates L Systems, an example of the usefulness of modularity.}
 \label{fig:tree_generation}
\end{figure}

As seen in fig~\ref{fig:tree_generation}, modularity can be extremely useful. This method has three L-Systems defined, but we can theoretically define as many L-Systems as the vector (a class-private single dimension vector instance variable named \textit{trees\_} ) can hold. Once all L-Systems are defined, the program then iterates over the vector storing them, generating then and then binding the vertices to OpenGL's vertex buffer. The program will simply display as many L-Systems as defined, without the need for any additional code. In separating out functionality into modular classes and functions, it is not an issue to tweak and adjust the program once the overall structure has been implemented.

\subsection{Initial Class Structure}
The classes were initially designed as follows. Quadtrees had not yet been considered upon initial class design. As this was an initial design, this was intended more of a rough outline rather than a concrete architecture. The idea was that the project could build from the core intention of this design, rather than rigidly sticking to it. 

\subsection{Main.cpp}

The class Main.cpp will initially be based off of the tutorials found on http://opengl-tutorial.org~\cite{opengl_tutorial}.

\subsubsection{Instance Variables}
\textit{GLFWwindow window.} 

This class will only store a variable of the window being used, as it is needed for OpenGL's draw loop.
\subsubsection{Functions}
\textit{int main()}\\
This class will contain the "main" function for the project, the designated start of the program. \\

\textit{void OpenGLMagic}\\
This method will set up what is necessary for OpenGL to draw the world, before entering the draw loop.


\subsection{DiamondSquare.cpp}

This class will handle all things to do with Diamond Square generation. 

\subsubsection{Instance Variables}

Diamond Square will store the heightmap initially generated, allowing for it to be easily accessible to other classes.

\subsubsection{Methods}

\textit{GenerateHeightMap}\\
This method will generate the heightmap, by following the Diamond Square algorithm. \medskip

\textit{Generate Vertices}
This method will take the heightmap generated, and from it generate vertices which can be interpreted by OpenGL to draw triangles. 

\subsection{L\_System.cpp}
This class handles all things to do with L\_System generation.

\subsubsection{Structs}

\textbf{Rule}\\
\textit{char axiom}\\
\textit{string rule}\medskip

The rule Structure helps us represent rules to apply to the L-System string. For example, in the rule "B -> AB", "B" is the axiom, and "AB" is the rule.

\subsubsection{Instance Variables}
\textit{string seed} - the initial seed the L\_System grows from\\
\textit{string fractal string} - the final string after iterations\\
\textit{int no\_of\_iterations} - the number of times the string will be iterated over\\
\textit{angle\_mod} - the angle of which to turn\\
\textit{rules} - all the rules to be applied to the seed\\
\textit{vertices} - the eventual interpretation of the final string as a set of vertices\\

\subsubsection{Methods}

\textit{Generate Fractal}\\

This method will take the seed, iterate over it  "no\_of\_iterations" times, following the rules stored in the class.

\textit{Generate Vertices}\\

This method will take the final fractal string and interpret it according to the rules of Turtle Graphics.

\clearpage

\section{Final Design}

Much like in fig~\ref{architecture}, the final design is split up into two parts - the classes relevant to OpenGL, and the classes generating the vertices to push to OpenGL. Due to the size of the full UML chart, these two sections have also been broken down into separate charts.

\begin{figure}[h!]
\centering
  \includegraphics[width=1\textwidth]{OpenGL_UML.png}
 \caption{UML of classes relating to OpenGL}
 \label{fig:opengl_uml}
\end{figure}


\subsection{OpenGL Related Class Structure}

The following classes are related to the OpenGL half of my project. They include the main class (\textit{main.cpp)}, Shaders(\textit{shader.cpp}, \textit{ColorFragmentShader.fragmentshader}, \textit{TransformVertexShader.vertexshader}, \textit{l\_system\_colour.frag.glsl}, \textit{l\_system\_transform.vert.glsl}, and the class which recalculates the camera's MVP, as well as handles user input (\textit{controls.cpp}). When creating the project, the tutorials found on http://opengl-tutorial.org~\cite{opengl_tutorial} were followed. Some of the code used within those tutorials was reused in this project, with permission. \textit{shader.cpp}, \textit{ColorFragmentShader.fragmentshader} and \textit{TransformVertexShader.vertexshader} remain unchanged when compared with tutorial code. \textit{l\_system\_colour.frag.glsl} and \textit{l\_system\_transform.vert.glsl} were written independently, but with guidance from previous tutorial files. \textit{controls.cpp} and \textit{main.cpp}) began initially as code simply taken from the tutorial, but both have had extensive reworks and changes, when compared to the initial code provided by the tutorial. Specifically, whilst the methods \textit{computeMatricesFromInputs()}, \textit{getViewMatrix()} and \textit{getProjectionMatrix()} remain largely unchanged from tutorial code, the rest of \textit{controls.cpp} is my own work. In \textit{main.cpp}, most of the function \textit{WindowSetup()} is largely unchanged when compared to tutorial code, but the rest of the class is my own work, based off of the initial code learnt from the tutorial. \\

\subsection{main.cpp} 

This class controls everything else in the program, as well as sets up a window and then displays the vertices needed into the window. Whilst this could have been abstracted out into a different class which this class calls, it would have been functionally identical, so the decision was made to keep the code in \textit{main.cpp}. In the method \textit{OpenGLMagic()}, it uses the method in shader.cpp, passing into it all four GLSL shaders. \\

This class sets up a window, before setting up everything needed to display the vertices in the window, using the World Maker class. Then each draw loop, it checks for user input, computes the camera's position, before drawing the terrain followed by the L-Systems.


\subsection{controls.cpp}

This class recalculates the camera's MVP (Model, View, Perspective) matrix and handles user input. Whilst this class was intially a class brought over from work done on tutorials, it was eventually reworked into an object, in order to make code easier to read. As well as this, it keeps track of user input, to allow for functionality such as changing the Level Of Detail displayed on screen, or changing the colour palette. 

\subsection{shader.cpp}
This class was provided by the tutorials followed. It compiles the shaders, passing them to the driver, before returning a shader ID for us to access them by. 

\subsection{TransformVertexShader.vertexshader}
This shader was provided by the tutorials followed. It takes in a vertex position and colour, outputs the position multiplied by the MVP matrix, and passes out the color to the fragment shader.


\subsection{ColorFragmentShader.fragmentshader} This shader simply takes in the color and then outputs it again. It is here more for future proofing, so we can easily have more complex shaders in the future.  

\subsection{l\_system\_transform.vert.glsl}
Unlike TransformVertexShader, this shader takes in the l\_system vertices, and then a separate vector containing its position. It then positions the mesh in the vector containing its position.


\subsection{l\_system\_colour.frag.glsl}
This shader is identical to ColorFragmentShader.fragmentshader. It only exists again for future proofing the project. 


\clearpage
\subsection{Procedural Generation Class Structure}

\begin{figure}[h!]
\centering
  \includegraphics[width=1\textwidth]{GenerationUML.png}
 \caption{UML of classes relating to OpenGL}
 \label{fig:GenerationUML}
\end{figure}

The majority of the code in the classes listed below is all my own work. The only method sourced externally is \textit{ResizeVector2} in \textit{diamond\_square.cpp}, which was gained from http://www.cplusplus.com/forum/beginner/102670/ .

\subsection{world\_maker.cpp}
WorldMaker is integral to the entire project. It controls the generation of everything within the world, specifying the order in \textit{MakeWorld()}, which takes in pointers to GLuints storing the ids for each vertexbuffer. \textit{MakeWorld()} first calls \textit{ComputeFullDiamondSquareBuffers()}, which gets DiamondSquare to generate the terrain vertices, before binding them to the vertex buffer. It then calls \textit{ComputeDiamondSquareColourBuffers()}, telling it to initially generate the colours in the blended colour palette. Once the colours have been generated, \textit{MakeWorld} then calls \textit{ComputeLSystemVertexBuffer()}, which generates the L-System vertices needed, followed by the generation of positions for the trees.

\subsection{struct ColourList}
This struct simply provides a point of access to the list of colours used to colour in the landscape.

\subsection{diamond\_square.cpp}

This class holds all the methods needed for generating a Diamond Square based Height Map, and converting that heightmap into vertices. When the constructor is called, once it has intialised all variables it then calls \textit{GenerateHeightMap()}, which generates \textit{n} number of height maps (where \textit{n = no\_of\_iterations}). Each iteration is representative of a different Level of Detail. \textit{GenerateVertices()} is called during world generation. It iterates over every heightmap generated, producing its equivalent vertices to display. 

\subsection{l\_system.cpp}
l\_system.cpp holds all the methods needed to generate one Lindenmayer System fractal. An L-System is first built up by defining the seed, number of iterations, angle modifier and scale in the constructor. Rules are then added, before generating the final iteration of the fractal string, with \textit{GenerateFractal()}. After generating the fractal, \textit{GenerateVertices()} is called, which generates the vertices to represent the tree through OpenGL.

\subsection{struct Rule}
This struct holds an axiom and a rule of which the axiom is replaced by. 

\subsection{terrain\_quad\_tree.cpp}
terrain\_quad\_tree.cpp is an implementation of a Quadtree. It simply has two instance variables, the Quadtree's root, and the number of iterations the Quadtree will run for. This class is a proof of concept for LOD tessellation. Whilst in practice the class itself is not optimised enough for live implementation, if it were to be used, GenerateQuadTree() is first called, which iterates over the heightmap, generating a quad tree, with smaller nodes being closer to the camera's position. Once it has been generated, GenerateVertices() is then called, which generates a set of vertices of stitched together heightmaps, as a quadtree. 

\subsection{struct Node}
Node is a struct used in terrain\_quad\_tree.cpp, which holds four nodes (representative of the Node's potential four children), details of its boundary, what level of detail it is and whether it is a leaf or a parent.


\clearpage

\section{Algorithms}
\subsection{Diamond Square}
The Diamond Square algorithm~\cite{miller1986definition}, is an algorithm which randomly generates fractal based terrain, iterating over terrain using two steps - Diamond and Square. \medskip 

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.9\textwidth]{Diamond_Square}
 \caption[Diamond Square steps, by Christopher Ewin]{Diamond Square steps, by Christopher Ewin CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=42510593}
 \label{fig:diamond_square_steps}
\end{figure} 

Diamond Square is performed on an initially flat grid. The steps (as pictured in fig~\ref{fig:diamond_square_steps}) are as follows:

\begin{enumerate}
\item \textit{Initialise corner values}
\item \textit{Diamond Step}
\item \textit{Square Step}
\item \textit{Reduce step size} 
\item \textit{Repeat Steps 2-4 while step size is greater than 1}
\end{enumerate} 

The Step Size (used in both the Square Step and the Diamond Step) is initialised to the grid's width -1. The Diamond step takes each square in the grid, of width Step Size, and sets the midpoint of the square to the average of its corner values, in addition to a random value (which decreases alongside Step Size). The Square step takes each diamond in the gird of width Step Size and sets the midpoint of the diamond to the average of its corner values, in addition to a random value (which decreases alongside Step Size). \medskip

One of the main issues with Diamond Square are edge values - whilst all other values gain their height from the average of 4 other values, edge cases don't have enough data around them for this. There are two solutions to this - use the 3 available values, or wrap round the values to the other side of the grid. 

\subsection{Lindenmayer Systems}


\begin{wrapfigure}{r}{4cm}
\centering
  \fbox{\includegraphics[width=0.11\textwidth]{AB_Example.png}}
 \caption{Diagram illustrating an L-System's iterative process}
 \label{fig:l_system_AB}
\end{wrapfigure}


Lindenmayer System is a String manipulation algorithm, which recursively iterates over a String according to a set of rules in order to generate a String representation of a fractal pattern. It's steps are as follows:


1. Define initial String seed
2. Define the L-System's rules
3. Iterate over the string \textit{n} times, following the defined rules


A simple example:\medskip

\textbf{Seed:} \textit{"A"}

\textbf{Rule 1:} \textit{A $\rightarrow$ AB}

\textbf{Rule 2:} \textit{B $\rightarrow$ A}


Iteration 0: A

Iteration 1: AB

Iteration 2: ABA

Iteration 3: ABAAB

Iteration 4: ABAABABA

Iteration 5: ABAABABAABAAB\medskip



In Figure \ref{fig:l_system_AB}, Patterns can be generated easily and quickly. The next stage of Lindenmayer Systems is interpreting these patterns into something we can draw - this is achieved using "Turtle Graphics". The book, The Algorithmic Beauty of Plants~\cite{prusinkiewicz2012algorithmic} contains a comprehensive explanation of Lindenmayer Systems including these rules for 3D Lindenmayer Patterns:\medskip

F: Move forward, by step \textit{d} and orientation \textit{n}. A line between {x, y, z} and {x', y', z'} is drawn. \\

f: Move forward, by step \textit{d} and orientation \textit{n}. \\

+: Turn left by angle $\sigma$ along the xy axis (using the z rotation matrix)\\

-: Turn right by angle $\sigma$ along the xy axis (using the z rotation matrix)\\

\&: Pitch down by angle $\sigma$ along the xz axis (using the y rotation matrix)\\

$\wedge$: Pitch up by angle $\sigma$ along the xz axis (using the y rotation matrix)\\

\textbackslash: Roll left by angle $\sigma$ along the yz axis (using the x rotation matrix)\\

/: Roll right by angle $\sigma$ along the yz axis (using the x rotation matrix)\\

|: Turn around along the xy axis (180 degrees using the z rotation matrix)\\

[: Push the current state of the turtle onto a stack\\

]: Pop a state from the stack and apply it to the turtle\medskip

These rules expand the usefulness of Lindenmayer Systems and are especially useful for this project, as they allow for branching structures, allowing us to create trees.

\clearpage
\subsection{Terrain LOD}

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.3\textwidth]{QuadTree.png}
 \caption{Quadtree example. The darker the shade, the higher detailed the terrain in that area. White circle denotes where the camera is.}
 \label{fig:quad_tree}
\end{figure}

One of the biggest optimisation's to be made for this project will be Terrain Level Of Detail (LOD). This optimisation is split into two parts - the generation of the different levels of detail, alongside the combining of them, and deciding the amount of vertices to display. This could be done dynamically, but lacking the time and definition  to implement the complexity of a dynamic terrain renderer, instead we have something easier to use. Diamond Square, upon generating its terrain automatically generates different levels of detail which can easily used for this algorithm. These levels of detail can then be stitched together, depending on the technique used for LOD display. \medskip

An often used technique for deciding what LOD each chunk of terrain will be is using a Quadtree system to split up terrain~\cite{pajarola1998large}. A Quadtree is a tree structure where each node has exactly four children. As seen in Figure~\ref{fig:quad_tree}, this tree structure can easily be applied to splitting up terrain. In Figure~\ref{fig:quad_tree}, each shade (as denoted by the numbers) represents a different Level Of Detail - the darker the shade, the higher the detail. whilst this can easily work, the main problem are cracks between each chunk of terrain. This can potentially be solved by working averaging the edges to the midpoint of each other, but this could potentially prove problematic as each edge has different numbers of triangles. A crude solution would involve moving the edge vertices of the edge triangles up to the same elevation as the edge of their neighbouring chunk. \medskip

A solution to this problem is known as Restricted Quadtree Triangulation~\cite{pajarola1998large}. This works by restricting triangulation to points that match. Whilst this is definitely a more elegant method, time restrictions have stopped me from implementing this. 

\subsection{L-System Rendering Optimisation Techniques}
L-Systems when displayed on screen may use a lot of vertices, especially if displayed using 3D Primitives such as cylinders. In order to reduce the amount of vertices displayed we can use a similar technique to Terrain LOD; the further away the trees are from the camera, the less detail they display. However, unlike the terrain, we cannot simply reduce the number of vertices in the tree. Instead, we use Billboards and Impostors. When the tree is far enough away, we simply replace it with a two dimensional sprite of the orientation of the tree facing you - known as an \textit{Impostor}. A billboard is used, when the tree is further away. Rather than choosing from a number of orientations of the tree to display, there is simply one, which is rotated to constantly face the camera. Due to the distance of the tree from the camera, the angle of which it is viewed does not matter, so we can simply display one orientation of it to the user.


\chapter{Sprints}

At the start of each week, stories/sprint goals were set out of what was the week was aiming to achieve. The structure of a story was roughly:\medskip

\textit{"As a \_\_\_\_\_\_, I need to \_\_\_\_\_\_, so that I can \_\_\_\_\_\_"}

\section{Sprint 1 (12/02/18 - 18/02/18)}

\subsection{Sprint Goals}

\begin{enumerate}
  \item \textit{As the Developer, I need to become more familiar with C++ and OpenGL, so that I can properly get going with the project. I will achieve this through research into the implementation of OpenGL and going through an OpenGL tutorial which I have already begun.}
  
  \item \textit{As the Student, I need to start thinking about my Major Project's Report, so that I will not have an overload of writing at Easter. I will achieve this by setting out the sections of my report and making a start on the introduction.}
  \item \textit{As the Developer, I need to have a strong idea of how I am going to implement my project, in order to prevent floundering and confusion later on. I will achieve this through more Software Engineering Design Pattern and Architectural Pattern research. }
\item \textit{As the Developer, I need a good idea of how much time I have left before my various deadlines, so that I can increase my drive to work. I will achieve this through further improving my Gantt Chart, namely adding more strong Major Project deadlines. }

\end{enumerate}

\subsection{Sprint Summary}

The first sprint's main aim was to lat a good foundation on which to build the rest of my project. This was achieved through working through a set of OpenGL Tutorials~\cite{opengl_tutorial}, tweaking the project's Gantt Chart and Outline Spec, researching into potential Design Patterns (Model View Controller), learning more about OpenGL's general architecture, and more 3D Graphics basics (in particular, Model, View and Projection). \medskip

A significant accomplishment was being able to display two different items in OpenGL. Whilst this may seem trivial, and an easy accomplishment, it meant the culmination of the knowledge learnt throughout the entire week - representing objects through vertices, Vertex Buffers and Colour Buffers, basic C++ syntax, and OpenGL syntax.\medskip

\clearpage
\section{Sprint 2 (19/02/18 - 25/02/18)}

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.5\textwidth]{Sprint2-1.png}
 \caption{Initial triangles displayed. OpenGL essentially displaying garbage as both major algorithms within the DiamondSquare class were incorrectly implemented}
 \label{fig:sprint2-1}
\end{figure}

\subsection{Sprint Goals}
\begin{enumerate}
    \item \textit{As the Developer, I need to set up a private git repository so that I can properly use version control in order to avoid major project screwups.
    }
    \item \textit{As the Developer, I need to begin implementation, in order to hit deadlines and be prepared enough for my mid project demonstration.}
    \item\textit{As the Student, I need to continue working on my Report and identify which sections to work on this week so that I don't leave it to the last minute.}
    
\end{enumerate}

\subsection{Sprint Summary}

The second sprint's main aim was to finish building the foundation which was begun in the first sprint, whilst also beginning to implement some Diamond Square code. This was achieved through setting up an initial private Github repository, creation of the initial \LaTeX report file, and a first pass at the initial Diamond Square algorithm implementation. Throughout this sprint, a lot of learning of both OpenGL and C++'s syntax was taking place.  \medskip

A significant accomplishment was being able to generate triangles without hardcoding the vertices for them. Even though a lot of the vertices in the triangles turned out to be OpenGL displaying garbage values it had been provided with (as seen in Fig~\ref{fig:sprint2-1}, the thrill of being able to show something on the screen, and being able to debug the project not only using the debugger but also visually, was a big achievement. 

\clearpage

\section{Sprint 3 (26/02/18 - 04/03/18)}

\begin{figure}[h!]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint3-2.png}
  \captionof{figure}{Generation of a flat plane}
  \label{fig:sprint3-2}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint3-3.png}
  \captionof{figure}{Initial output of the broken Diamond Square algorithm}
  \label{fig:sprint3-3}
\end{minipage}
\end{figure}

\subsection{Sprint Goals}
\begin{enumerate}
    \item \textit{As the Developer, I need to continue working on my Diamond Square Algorithm - fixing the algorithm itself and using the heightmap to generate a grid, so that I can have usable terrain. }
\end{enumerate}
\subsection{Sprint Summary}
The third sprint's main aim was to continue to improve on the Diamond Square Algorithm, and perform small tweaks on the rest of the code. This was achieved by successfully interpreting a heightmap into vertices, as well as continued iteration over the Diamond Square algorithm in order to bring it to a successful implementation state. Personally, this week was very busy, and so not as much work could be achieved in comparison to other Sprints. \medskip

A significant accomplishment of this sprint was both implementing the Camera's movement, as well as generating a flat plane, before applying the heightmap to the plane. This was buckets ahead of the previous week, and gave ample motivation to keep pressing ahead to make the Diamond Square algorithm work. 

\clearpage
\section{Sprint 4 (05/03/18 - 11/03/18)}

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.5\textwidth]{Sprint4-7.png}
 \caption{Final state of the Diamond Square terrain by the end of the Sprint}
 \label{fig:sprint4-1}
\end{figure}

\subsection{Sprint Goals}
\begin{enumerate}
    \item \textit{As the Developer I need to fix/re implement the Diamond Square algorithm so that it generates suitably random terrain, so that I can begin to implement details and have something impressive for my Mid Project Demonstration. }
    \item \textit{As the Developer, I want to implement some code to make colour based on the height of the vertex, so that the terrain is not simply random colours.}
    \item \textit{As the Developer, I want to increase the size and scalability of the Heightmap Implementation, allowing for more vertices to be displayed on screen, whilst shrinking the current vertices. }
    \item \textit{As a student, I want to make a poster highlighting my project, in order to submit it for CS38220.}
    \item \textit{As a student I need to begin to prepare for my mid project demonstration, in order to be able to present something of high enough quality. }
    
\end{enumerate}
\subsection{Sprint Summary}

The fourth sprint's main aim was to bring the Diamond Square Algorithm to a stage where it generated suitable terrain, as well as beginning to implement colour vertex code. The week also coincided with creation of a poster detailing the project, for a separate module. This was achieved by even more iteration on the Diamond Square algorithm, adjusting it to allow for it to output larger vertex buffers. Colour Vertex Buffers were begun to be worked on, but required more time than initially scoped for, due to syntax issues and the implementation being more complicated than initially thought.  \medskip

A significant accomplishment during this sprint was managing to get the code to output vertices that began to take the correct form - becoming more \textit{terrain-like} in nature (see fig~\ref{fig:sprint4-1}) , instead of one long curve (see fig~\ref{fig:sprint3-3}), as in the previous sprint. 

\clearpage

\section{Sprint 5 (12/03/18 - 18/03/18)}

\begin{figure}[h!]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint5-3.png}
  \captionof{figure}{Initial terrain generation}
  \label{fig:sprint5-3}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint5-6.png}
  \captionof{figure}{Top down view of the terrain}
  \label{fig:sprint5-6}
\end{minipage}
\end{figure}


\subsection{Sprint Goals}

\begin{enumerate}
    \item \textit{As a developer, I need to continue to look at the Diamond Square Algorithm and fully fix it this week - it is very nearly fixed, but continues to need tweaking. It would be good to have it working fully for my mid project demo. }
    \item \textit{As a student, I need to continue work on my report, so that I don't fall too far behind overall.}
    \item \textit{As the Developer, I want to increase the size and scalability of the Heightmap Implementation, allowing for more vertices to be displayed on screen, whilst shrinking the current vertices. }
    \item \textit{As a developer, I'd like to add some basic colours to the heightmap, to make it look more natural.}
    \item \textit{As a student, I need to finish prepping for my mid project demo, so that I can demo it well to my 2nd marker. }
    
\end{enumerate}
\subsection{Sprint Summary}

The fifth sprint's main aim was to finish work on the Diamond Square algorithm, which included vertices generated, size of grid and colour of grid. This was achieved through solving the final bugs in the Diamond Square algorithm, implementing multiple arrays defined by the size of the grid given to the method and a method which sets a vertex colour depending on its height. This was one of the most rewarding sprints of the entire project, as the terrain went from a glitchy multicoloured mess, to a cohesive plane, which was recognisable as terrain. This sprint was the last sprint I gave myself to work on the Diamond Square algorithm, as otherwise there would be not enough time left to work on other aspects of the project, so successfully implementing the terrain was a big relief. \medskip

A significant accomplishment during this sprint was implementing colour into the terrain. As this project is graphics based, what appears onscreen is what matters most, so in implementing both colour and terrain in one sprint, the project's quality was lifted significantly.

\clearpage

\section{Sprint 6 (19/03/18 - 26/03/18)}


\begin{figure}[h!]
\centering
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint-7-After-Colour.png}
    \captionsetup{width=.9\linewidth}
  \captionof{figure}{Edited Diamond Square, with blended colours}
  \label{fig:sprint7-c}
\end{minipage}%
\begin{minipage}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint-7-After-Greyscale.png}
    \captionsetup{width=.9\linewidth}
  \captionof{figure}{Diamond Square with a greyscale texture mapped to it (the higher the terrain, the lighter the colour)}
  \label{fig:sprint7-g}
\end{minipage}
\end{figure}

\subsection{Sprint Goals}

\begin{enumerate}
    \item \textit{As a developer, I need to begin to implement L-System trees, so that I can begin to look past simple implementation and move onto rendering optimisation.  }
    \item \textit{As a developer, I need to fix triangle culling, so that I can half the amount of triangles rendered and increase the frame rate of the program.}
    \item \textit{As a student, I need to write a lot more report to ensure that I am not falling behind. }
    \item \textit{This week also has a deadline for professional issues, which will interfere with my work for the major project.}
    
\end{enumerate}
\subsection{Sprint Summary}

The sixth sprint's main aim is to research and subsequently begin implementation of L-Systems, as well as fixing small issues, such as face culling and a blended colour implementation. This was achieved by a lot of L-System research, before initial implementation of a class and method to build the initial string, a well as a quick rewrite of the order the vertices were pushed to the Vertex Buffer in order to enable face culling and blending colours by getting a percentage in between two shades and applying this to the terrain to create a gradient, rather than a block of colour. \medskip

This sprint clashed with another module's assignment deadline, as well as the end of second semester, meaning that a day was lost to moving back home. However, in the last few minutes of the sprint, a change was made to Diamond Square which made the terrain a lot more detailed, instead of a smooth curve, the project gained a lot more of a realistic look. \medskip

A significant achievement during this sprint was fully understanding L-Systems. A lot of my initial research was focused on terrain generation and OpenGL syntax, so finding time to understand and begin to implement L-Systems meant that implementation would be better prepared for the coming sprints. \clearpage
\section{Sprint 7 (26/03/18 -  01/04/18)}

\subsection{Sprint Goals}

\begin{enumerate}

\item \textit{As a developer, I need to get L-Systems to an initial state of being rendered, so that I can focus on improving them and where they are placed.}

\item \textit{As a developer, I need to refactor the design of my code so that it is better structured and easier to maintain.}

\item \textit{As a student, I need to add a lot more to my report. }
\end{enumerate}

\subsection{Sprint Summary}

The seventh sprint's primary aim was to focus more on the write up of the project, as well as to prepare and begin implementation of L-Systems. This was achieved by researching GLM (OpenGL Mathematics)~\cite{creation2016opengl}, reading up more on L-System implementation~\cite{prusinkiewicz2012algorithmic} and beginning to implement the algorithms needed for L-Systems.\\

A significant achievement during this sprint was getting a significant chunk of the report written - at this stage of the project the report should be eating into development time more and more.


\section{Sprint 8 (02/04/18 -  08/04/18)}


\begin{figure}[h!]
\centering
\begin{minipage}{.3\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{tree1.png}
    \end{minipage}%
\begin{minipage}{.3\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{tree2.png}
\end{minipage}
\begin{minipage}{.3\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{tree3.png}
\end{minipage}
\caption{Three examples of 2D trees generated using L-Systems}
 \label{fig:sprint8}

\end{figure}
\begin{enumerate}
\subsection{Sprint Goals}

\item \textit{As a developer, I want to finish L-systems so I can get onto optimisations and restructuring the program as a hole.}

\item \textit{As a student, I want to start my second section of my report, whilst also redrafting my first section.}
\end{enumerate}

\subsection{Sprint Summary}

The eighth sprint's main aim was to fully implement L-Systems, as well as begin section two of the report. This will be achieved by implementing the rest of the L-System code, started in Sprint Seven. The trees were initially implemented using 2D maths, following examples in The Algorithmic Beauty of Plants~\cite{prusinkiewicz2012algorithmic}. The option to move the camera with WASD as well as the arrow keys was also added during this sprint. On top of this, code was cleaned up and restructured, a lot of world generation code moving into the World Maker class.

A significant achievement in this sprint was getting 2D L-Systems working (see fig~\ref{fig:sprint8}, meaning that the two key components to my project - terrain and trees are technically in. 


\clearpage
\section{Sprint 9 (09/04/18 -  15/04/18)}

\begin{figure}[h!]
    \centering
  \includegraphics[width=0.5\textwidth]{Sprint9-1.png}
 \caption{An example of instance rendering - only one copy of the each of the three models of trees is stored.}
 \label{fig:sprint9-1}
\end{figure}

\subsection{Sprint Goals}
\begin{enumerate}
    \item \textit{ As a developer, I am going to work on placing L-System objects, in order to create a dense scene.}

    \item \textit{ As a developer, I am going to look at and implement instance rendering for my L-System objects, in order to keep render time relatively low.}

    \item \textit{ As a developer, I am going to look at LOD and Billboarding, so that I can keep render time low.}

    \item \textit{ As a developer I am going to begin to look at my UI and how I can improve the current User Experience with my project.}

    \item \textit{ As a student, I want to start my second section of my report, whilst also redrafting my first section. }
\end{enumerate}


\subsection{Sprint Summary}

The ninth sprint was focused on implementing instance rendering, and redesigning the Diamond Square algorithm to store all of its generations, in order to then implement them with LOD optimisations. As well as this, my report was continually worked on. This was achieved by implementing instance rendering, alongside a basic tree placement method, as well as redesigning the Diamond Square class so that it saved each iteration it generated in a Vector. \medskip

A significant accomplishment this sprint was getting instance rendering working (see fig~\ref{fig:sprint9-1}. Instance rendering is a form of the Flyweight Design Pattern, and saves hugely on memory.

\clearpage
\section{Sprint 10 (16/04/18 -  22/04/18)}

\begin{figure}[h!]
\centering
\begin{minipage}{.3\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint10-1.png}
    \end{minipage}%
\begin{minipage}{.3\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint10-2.png}
\end{minipage}
\begin{minipage}{.3\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{Sprint10-3.png}
\end{minipage}
\caption{Three different Levels Of Detail of Terrain}
\end{figure}
\subsection{Sprint Goals}

\begin{enumerate}

    \item \textit{As a developer I want to further implement LOD for terrain, drastically cutting down on the amount of vertices rendered.}

    \item \textit{As a developer I am going to begin to look at my UI and how I can improve the current User Experience with my project.}

    \item \textit{As a developer, I am going to begin to implement unit tests into my code, in order to create a more robust program. }
    \item \textit{As a Student I want to add at least 2000+ more words to my report.}

\end{enumerate}

\subsection{Sprint Summary}

The tenth sprint's main aim was to add in Level Of Detail optimisations for terrain, look at implementing some UI and Unit Tests and do a lot of report work. Unit tests were implemented using Boost~\cite{boost}, UI was considered with NanoGUI~\cite{nanogui}. The most work was done on continuing to implement Quadtree LOD tessellation, continuing to adapt the Diamond Square class to store all of its iterations. \medskip

A significant accomplishment during this sprint was reworking my entire Diamond Square class to store all iterations. This prepares the project for the implementation of quadtrees in the following sprint. Getting Unit Tests up and going for the project was also a good achievement, as ensuring that everything is working by the end of the project is useful.


\clearpage
\section{Sprint 11 (23/04/18 -  29/04/18)}

\subsection{Sprint Goals}
\begin{enumerate}
    \item\textit{ As a developer I want to further implement LOD for terrain, drastically cutting down on the amount of vertices rendered.}

\item\textit{ As a developer I am going to begin to look at my UI and how I can improve the current User Experience with my project.}

\item\textit{ As a developer, I am going to continue to implement unit tests into my code, in order to create a more robust program. }

\item\textit{ As a developer, I want to have one more go at attempting to make my trees 3D. }

\item\textit{ As a Student I want to add at least 2000+ more words to my report.}

\end{enumerate}

\subsection{Sprint Summary}
Sprint Eleven's main aims were to tie up all loose ends in terms of programming, whilst finding time to continue to contribute to the report. This was achieved through getting a working version of Quadtree Level Of Detail optimisation (albeit one that had a negative effect on the frame rate rather than a positive one), more unit tests being implemented and more words being written. Quaternions were also used to replace the 2D maths in the L-Systems, but it was not sufficient enough progress to get 3D trees to work. \medskip

A significant accomplishment during this sprint was getting Quadtrees to work as intended.

\section{Post Sprint Progress}
The sprints were planned to finish to give me five days to focus on writing my report and chasing up any loose ends (such as further unit tests). A couple more features were also added to the project, in order to ensure that the final demo of the project goes smoothly. These were mainly keyboard shortcuts to perform the following actions:

\begin{itemize}
    \item Displaying and hiding the terrain
    \item Displaying and hiding the L-Systems
    \item Selecting a Level Of Detail to display
    \item Selecting a colour palette to display
\end{itemize}

\chapter{Tests}

\chapter{Implementation Results}
\section{Analysis}

\subsection{Implementation Challenges}
\subsection{Overall Problems and Issues}
\section{Future Additions}

\chapter{Conclusion and Evaluation}
\section{Evaluation}
\subsection{Project Aims}


\clearpage
\bibliographystyle{IEEEannot}
\bibliography{bibliography.bib}
\end{document}